package fr.javatronic.damapping.intellij.plugin.integration.provider;

import fr.javatronic.damapping.intellij.plugin.integration.index.MapperQualifiedNameIndex;
import fr.javatronic.damapping.intellij.plugin.integration.psiparsing.PsiParsingService;
import fr.javatronic.damapping.intellij.plugin.integration.psiparsing.impl.PsiParsingServiceImpl;
import fr.javatronic.damapping.processor.model.DASourceClass;
import fr.javatronic.damapping.processor.sourcegenerator.DefaultFileGeneratorContext;
import fr.javatronic.damapping.processor.sourcegenerator.FileGeneratorContext;
import fr.javatronic.damapping.processor.sourcegenerator.SourceGenerationService;
import fr.javatronic.damapping.processor.sourcegenerator.SourceGenerationServiceImpl;
import fr.javatronic.damapping.processor.sourcegenerator.SourceGenerator;
import fr.javatronic.damapping.processor.sourcegenerator.SourceWriterDelegate;
import fr.javatronic.damapping.processor.validator.DASourceClassValidator;
import fr.javatronic.damapping.processor.validator.DASourceClassValidatorImpl;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import com.google.common.base.Optional;
import com.google.common.collect.Lists;

import com.intellij.ide.highlighter.JavaFileType;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.psi.JavaDirectoryService;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiDirectory;
import com.intellij.psi.PsiElementFinder;
import com.intellij.psi.PsiFileFactory;
import com.intellij.psi.PsiJavaFile;
import com.intellij.psi.PsiPackage;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.util.Processor;
import com.intellij.util.indexing.FileBasedIndex;
import org.codehaus.groovy.runtime.StringBufferWriter;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * DAMappingElementFinder - IDEA extension responsible for making interfaces generated by the DAMapping annotation
 * processor visible to IDEA even though the annotation processor hasn't run thus providing feedback to the user
 * that her usage of generated interfaces is valid or not.
 *
 * @author SÃ©bastien Lesaint
 */
public class DAMappingElementFinder extends PsiElementFinder {
  private static final Logger LOGGER = Logger.getInstance(DAMappingAugmentProvider.class.getName());

  private final PsiParsingService parsingService;
  private final DASourceClassValidator sourceClassValidator;
  private final SourceGenerationService sourceGenerationService;

  public DAMappingElementFinder() {
    this(new PsiParsingServiceImpl(), new DASourceClassValidatorImpl(), new SourceGenerationServiceImpl());
  }

  public DAMappingElementFinder(PsiParsingService parsingService, DASourceClassValidator sourceClassValidator,
                                SourceGenerationService sourceGenerationService) {
    this.parsingService = parsingService;
    this.sourceClassValidator = sourceClassValidator;
    this.sourceGenerationService = sourceGenerationService;
    LOGGER.debug("DAMappingElementFinder created");
  }

  // TODO no processing if project is dumb or plugin is not enabled on project
//  final Project project = element.getProject();
//  if (DumbService.getInstance(project).isDumb()) {
//    LOGGER.debug("Index rebuilding in progress");
//    return Collections.emptyList();
//  }

  @Nullable
  @Override
  public PsiClass findClass(@NotNull String qualifiedName, final @NotNull GlobalSearchScope scope) {    // FIXME : ignore methods call if scope is not project (or even a module with activated DAMapping support ?)
    List<Void> values = FileBasedIndex.getInstance().getValues(MapperQualifiedNameIndex.NAME, qualifiedName, scope);
    if (values.isEmpty()) {
      return null;
    }

    PsiClass psiClass1 = Common.generateClass(scope, qualifiedName);
    if (psiClass1 != null) {
      return psiClass1;
    }


//    DASourceClass daSourceClass = parsingService.parse(psiClass);
//    try {
//      sourceClassValidator.validate(daSourceClass);
//    } catch (ValidationError validationError) {
//      LOGGER.error("Validation failed", validationError);
//      return null;
//    }
//
//    try {
//      PsiClassGeneratorDelegate delegate = new PsiClassGeneratorDelegate(scope.getProject());
//      switch (searchedClassType) {
//        case MAPPER_INTERFACE:
//          sourceGenerationService.generateMapperInterface(
//              new DefaultFileGeneratorContext(daSourceClass),
//              delegate
//          );
//          break;
//        case MAPPER_FACTORY_INTERFACE:
//          sourceGenerationService.generateMapperFactoryInterface(
//              new DefaultFileGeneratorContext(daSourceClass),
//              delegate
//          );
//          break;
//      }
//      return delegate.getGeneratedPsiClass();
//    } catch (IOException e) {
//      LOGGER.error("Failed to generate source files");
//    }

    return null;
  }

  @NotNull
  @Override
  public PsiClass[] findClasses(@NotNull String qualifiedName, @NotNull GlobalSearchScope scope) {
    PsiClass aClass = findClass(qualifiedName, scope);
    if (aClass == null) {
      return PsiClass.EMPTY_ARRAY;
    }
    return new PsiClass[]{aClass};
  }

  @Nullable
  @Override
  public PsiPackage findPackage(@NotNull String qualifiedName) {
    return super.findPackage(qualifiedName); // use super method because we do not generate any new package
  }

  @NotNull
  @Override
  public PsiPackage[] getSubPackages(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope) {
    return super.getSubPackages(psiPackage, scope); // use super method because we do not generate any new package
  }

  @NotNull
  @Override
  public PsiClass[] getClasses(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope) {
    if (psiPackage.getQualifiedName().startsWith("fr.javatronic.damapping.demo.view.mapper")) {
    List<PsiClass> res = Lists.newArrayList();
    for (PsiDirectory dir : psiPackage.getDirectories(scope)) {
      PsiClass[] classes = JavaDirectoryService.getInstance().getClasses(dir);

      for (PsiClass psiClass : Arrays.asList(classes)) {

//        if (!hasMapperAnnotation(psiClass)) {
//          // class is not annoted, ignore it
//          continue;
//        }

//        DASourceClass daSourceClass = parsingService.parse(psiClass);
//        try {
//          sourceClassValidator.validate(daSourceClass);
//        } catch (ValidationError validationError) {
//          LOGGER.debug(String.format("Failed to validate class %s", psiClass.getQualifiedName()), validationError);
//          continue;
//        }

        PsiClass psiClass1 = Common.generateClass(scope, psiClass.getName());
        if (psiClass1 != null) {
          res.add(psiClass1);
        }

//        try {
//          for (PsiClassGeneratorFacade generatorFacade : ImmutableList.of(
//              new MapperInterfaceFacade(daSourceClass, scope, sourceGenerationService),
//              new MapperFactoryInterfaceGenerator(daSourceClass, scope, sourceGenerationService)
//              ,
//              new MapperImplGenerator(daSourceClass, scope, sourceGenerationService),
//              new MapperFactoryImplGenerator(daSourceClass, scope, sourceGenerationService),
//              new MapperFactoryClassGenerator(daSourceClass, scope, sourceGenerationService)
//          )) {
//            Optional<PsiClass> generatePsiClass = generatorFacade.generatePsiClass();
//            if (generatePsiClass.isPresent()) {
//              res.add(generatePsiClass.get());
//            }
//
//          }
//        } catch (IOException e) {
//          LOGGER.error("Failed to generate source files");
//        }
      }
    }

    return res.toArray(new PsiClass[res.size()]);
    }
    return super.getClasses(psiPackage, scope);
  }

  private static abstract class PsiClassGeneratorFacade {
    protected final FileGeneratorContext generatorContext;
    protected final GlobalSearchScope scope;
    protected final SourceGenerationService sourceGenerationService;

    private PsiClassGeneratorFacade(DASourceClass daSourceClass, GlobalSearchScope scope,
                                    SourceGenerationService sourceGenerationService) {
      this.scope = scope;
      this.sourceGenerationService = sourceGenerationService;
      this.generatorContext = new DefaultFileGeneratorContext(daSourceClass);
    }

    private Optional<PsiClass> generatePsiClass() throws IOException {
      if (shouldGenerate()) {
        PsiClassGeneratorDelegate delegate = new PsiClassGeneratorDelegate(scope.getProject());
        generate(delegate);
        return Optional.of(delegate.getGeneratedPsiClass());
      }
      return Optional.absent();
    }

    protected abstract boolean shouldGenerate();

    protected abstract void generate(PsiClassGeneratorDelegate delegate) throws IOException;

  }

  private static class PsiClassGeneratorDelegate implements SourceWriterDelegate {
    private final Project project;
    private PsiClass generatedPsiClass;

    private PsiClassGeneratorDelegate(Project project) {
      this.project = project;
    }

    private PsiClass getGeneratedPsiClass() {
      return generatedPsiClass;
    }

    @Override
    public void generateFile(SourceGenerator sourceGenerator, FileGeneratorContext context) throws IOException {
      StringBuffer buffer = new StringBuffer();
      sourceGenerator.writeFile(new BufferedWriter(new StringBufferWriter(buffer)), context);
      // ((PsiJavaFile) PsiFileFactory.getInstance(project).createFileFromText(sourceGenerator.fileName(context), JavaFileType.INSTANCE, buffer.toString(), LocalTimeCounter     .currentTime(), false, false)).getClasses()[0].getImplementsListTypes()
      PsiJavaFile psiJavaFile = (PsiJavaFile) PsiFileFactory.getInstance(project)
                                                            .createFileFromText(sourceGenerator.fileName(context),
                                                                JavaFileType.INSTANCE, buffer.toString()
                                                            );
      this.generatedPsiClass = psiJavaFile.getClasses()[0];
    }

  }

  private static class MapperInterfaceFacade extends PsiClassGeneratorFacade {

    private MapperInterfaceFacade(DASourceClass daSourceClass,
                                  GlobalSearchScope scope,
                                  SourceGenerationService sourceGenerationService) {
      super(daSourceClass, scope, sourceGenerationService);
    }

    @Override
    protected boolean shouldGenerate() {
      return true;
    }

    @Override
    protected void generate(PsiClassGeneratorDelegate delegate) throws IOException {
      sourceGenerationService.generateMapperInterface(generatorContext, delegate);
    }
  }

  private static class MapperFactoryInterfaceGenerator extends PsiClassGeneratorFacade {

    public MapperFactoryInterfaceGenerator(DASourceClass daSourceClass,
                                           GlobalSearchScope scope,
                                           SourceGenerationService sourceGenerationService) {
      super(daSourceClass, scope, sourceGenerationService);
    }

    @Override
    protected boolean shouldGenerate() {
      return sourceGenerationService.shouldGenerateMapperFactoryInterface(generatorContext);
    }

    @Override
    protected void generate(PsiClassGeneratorDelegate delegate) throws IOException {
      sourceGenerationService.generateMapperFactoryInterface(generatorContext, delegate);
    }
  }

  private static class MapperImplGenerator extends PsiClassGeneratorFacade {

    public MapperImplGenerator(DASourceClass daSourceClass,
                               GlobalSearchScope scope,
                               SourceGenerationService sourceGenerationService) {
      super(daSourceClass, scope, sourceGenerationService);
    }

    @Override
    protected boolean shouldGenerate() {
      return sourceGenerationService.shouldGenerateMapperImpl(generatorContext);
    }

    @Override
    protected void generate(PsiClassGeneratorDelegate delegate) throws IOException {
      sourceGenerationService.generateMapperImpl(generatorContext, delegate);
    }
  }

  private static class MapperFactoryImplGenerator extends PsiClassGeneratorFacade {

    public MapperFactoryImplGenerator(DASourceClass daSourceClass,
                                      GlobalSearchScope scope,
                                      SourceGenerationService sourceGenerationService) {
      super(daSourceClass, scope, sourceGenerationService);
    }

    @Override
    protected boolean shouldGenerate() {
      return sourceGenerationService.shouldGenerateMapperFactoryImpl(generatorContext);
    }

    @Override
    protected void generate(PsiClassGeneratorDelegate delegate) throws IOException {
      sourceGenerationService.generateMapperFactoryImpl(generatorContext, delegate);
    }
  }

  private static class MapperFactoryClassGenerator extends PsiClassGeneratorFacade {

    public MapperFactoryClassGenerator(DASourceClass daSourceClass,
                                       GlobalSearchScope scope,
                                       SourceGenerationService sourceGenerationService) {
      super(daSourceClass, scope, sourceGenerationService);
    }

    @Override
    protected boolean shouldGenerate() {
      return sourceGenerationService.shouldGenerateMapperFactoryClass(generatorContext);
    }

    @Override
    protected void generate(PsiClassGeneratorDelegate delegate) throws IOException {
      sourceGenerationService.generateMapperFactoryClass(generatorContext, delegate);
    }
  }

  @NotNull
  @Override
  public Set<String> getClassNames(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope) {
    return super.getClassNames(psiPackage, scope
    ); // super method uses getClasses(PsiPackage, GlobalSearchScope) in a way that suits us
  }

  @Override
  public boolean processPackageDirectories(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope,
                                           @NotNull Processor<PsiDirectory> consumer) {
    return super.processPackageDirectories(psiPackage, scope, consumer
    ); // don't know what's that method for, use supermethod for now
  }

  @NotNull
  @Override
  public PsiClass[] getClasses(@Nullable String className, @NotNull PsiPackage psiPackage,
                               @NotNull GlobalSearchScope scope) {
    return super.getClasses(className, psiPackage, scope
    ); // super method uses getClasses(PsiPackage, GlobalSearchScope) in a way that suits us
  }
}
