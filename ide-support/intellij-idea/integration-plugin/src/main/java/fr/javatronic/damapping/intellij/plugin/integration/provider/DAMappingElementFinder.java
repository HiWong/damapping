package fr.javatronic.damapping.intellij.plugin.integration.provider;

import fr.javatronic.damapping.annotation.Mapper;
import fr.javatronic.damapping.intellij.plugin.integration.psiparsing.PsiParsingService;
import fr.javatronic.damapping.intellij.plugin.integration.psiparsing.impl.PsiParsingServiceImpl;
import fr.javatronic.damapping.processor.model.DASourceClass;
import fr.javatronic.damapping.processor.sourcegenerator.DefaultFileGeneratorContext;
import fr.javatronic.damapping.processor.sourcegenerator.FileGeneratorContext;
import fr.javatronic.damapping.processor.sourcegenerator.SourceGenerationService;
import fr.javatronic.damapping.processor.sourcegenerator.SourceGenerationServiceImpl;
import fr.javatronic.damapping.processor.sourcegenerator.SourceGenerator;
import fr.javatronic.damapping.processor.sourcegenerator.SourceWriterDelegate;
import fr.javatronic.damapping.processor.validator.DASourceClassValidator;
import fr.javatronic.damapping.processor.validator.DASourceClassValidatorImpl;
import fr.javatronic.damapping.processor.validator.ValidationError;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Predicate;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;

import com.intellij.ide.highlighter.JavaFileType;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.fileTypes.FileTypes;
import com.intellij.openapi.project.Project;
import com.intellij.psi.PsiAnnotation;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiDirectory;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiElementFinder;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiFileFactory;
import com.intellij.psi.PsiImportList;
import com.intellij.psi.PsiImportStatement;
import com.intellij.psi.PsiJavaCodeReferenceElement;
import com.intellij.psi.PsiJavaFile;
import com.intellij.psi.PsiPackage;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.search.PsiShortNamesCache;
import com.intellij.util.Processor;
import org.codehaus.groovy.runtime.StringBufferWriter;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * DAMappingElementFinder - IDEA extension responsible for making interfaces generated by the DAMapping annotation
 * processor visible to IDEA even though the annotation processor hasn't run thus providing feedback to the user
 * that her usage of generated interfaces is valid or not.
 *
 * @author SÃ©bastien Lesaint
 */
public class DAMappingElementFinder extends PsiElementFinder {
  private static final Logger LOGGER = Logger.getInstance(DAMappingAugmentProvider.class.getName());

  private static final String MAPPER_INTERFACE_SUFFIX = "Mapper";
  private static final int MAPPER_INTERFACE_SUFFIX_LENGTH = MAPPER_INTERFACE_SUFFIX.length();
  private static final String MAPPER_FACTORY_INTERFACE_SUFFIX = "MapperFactory";
  private static final int MAPPER_FACTORY_INTERFACE_SUFFIX_LENGTH = MAPPER_FACTORY_INTERFACE_SUFFIX.length();
  private static final String MAPPER_ANNOTATION_TEXT = "@" + Mapper.class.getSimpleName();
  private static final String MAPPER_QUALIFIED_ANNOTATION_TEXT = "@" + Mapper.class.getName();

  private final PsiParsingService parsingService;
  private final DASourceClassValidator sourceClassValidator;
  private final SourceGenerationService sourceGenerationService;

  public DAMappingElementFinder() {
    this(new PsiParsingServiceImpl(), new DASourceClassValidatorImpl(), new SourceGenerationServiceImpl());
  }

  public DAMappingElementFinder(PsiParsingService parsingService, DASourceClassValidator sourceClassValidator,
                                SourceGenerationService sourceGenerationService) {
    this.parsingService = parsingService;
    this.sourceClassValidator = sourceClassValidator;
    this.sourceGenerationService = sourceGenerationService;
    LOGGER.debug("DAMappingElementFinder created");
  }

  @Nullable
  @Override
  public PsiClass findClass(@NotNull String qualifiedName, final @NotNull GlobalSearchScope scope) {
    SearchedClassType searchedClassType = computeSearchedClassType(qualifiedName);
    if (searchedClassType == null) {
      LOGGER.debug(String.format("class %s is not a class generated by DAMapping", qualifiedName));
      return null;
    }

    String mapperFile = extractMapperQualifiedName(qualifiedName, searchedClassType);
    PsiClass psiClass = retrieveSourceclass(mapperFile, scope);
    if (psiClass == null) {
      LOGGER.debug(String.format("Class %s not found", mapperFile));
      return null;
    }

    if (!hasMapperAnnotation(psiClass)) {
      LOGGER.debug(String.format("Class %s is not annoted with @Mapper", mapperFile));
      return null;
    }

    DASourceClass daSourceClass = parsingService.parse(psiClass);
    try {
      sourceClassValidator.validate(daSourceClass);
    } catch (ValidationError validationError) {
      LOGGER.error("Validation failed", validationError);
      return null;
    }

    try {
      PsiClassGeneratorDelegate delegate = new PsiClassGeneratorDelegate(scope.getProject());
      switch (searchedClassType) {
        case MAPPER_INTERFACE:
          sourceGenerationService.generateMapperInterface(
              new DefaultFileGeneratorContext(daSourceClass),
              delegate
          );
          break;
        case MAPPER_FACTORY_INTERFACE:
          sourceGenerationService.generateMapperFactoryInterface(
              new DefaultFileGeneratorContext(daSourceClass),
              delegate
          );
          break;
      }
      return delegate.getGeneratedPsiClass();
    } catch (IOException e) {
      LOGGER.error("Failed to generate source files");
    }

    return null;
  }

  private boolean hasMapperAnnotation(PsiClass psiClass) {
    if (psiClass.getModifierList() == null || psiClass.getModifierList().getAnnotations() == null) {
      return false;
    }

    // look for annotation @Mapper or @com.google.common.base.Function on class
    if (!FluentIterable.from(Arrays.asList(psiClass.getModifierList().getAnnotations()))
                       .filter(new Predicate<PsiAnnotation>() {
                         @Override
                         public boolean apply(@javax.annotation.Nullable PsiAnnotation psiAnnotation) {
                           return psiAnnotation != null
                               && (MAPPER_ANNOTATION_TEXT.equals(psiAnnotation.getText())
                               || MAPPER_QUALIFIED_ANNOTATION_TEXT.equals(psiAnnotation.getText()));
                         }
                       }
                       ).first().isPresent()) {
      return false;
    }

    // look for the import of Guava's Function
    for (PsiElement fileElement : psiClass.getParent().getChildren()) {
      if (fileElement instanceof PsiImportList) {
        for (PsiElement importListElement : fileElement.getChildren()) {
          if (importListElement instanceof PsiImportStatement) {
            for (PsiElement element : importListElement.getChildren()) {
              if (element instanceof PsiJavaCodeReferenceElement) {
                if (Function.class.getName().equals(element.getText())) {
                  return true;
                }
              }
            }
          }

        }
      }
    }
    return false;
    // ((PsiJavaFile)psiPackage.getDirectories(scope)[0].getFiles()[0]).getClasses()[0].getModifierList()
    // .getAnnotations()[0].getText() = "@Mapper"

    // ((PsiJavaFile)psiPackage.getDirectories(scope)[0].getFiles()[0]).getClasses()[0].getParent().getChildren()[0]
    // .getChildren() : import list to filter on type PsiImportStatement
    // PsiImportStatement to filter on PsiImportStatement.getChildren() : type PsiJavaCodeReferenceElement
    // PsiJavaCodeReferenceElement to filter on getText() = Function.class.getName()
  }

  private String extractMapperQualifiedName(String qualifiedName,
                                            @NotNull SearchedClassType searchedClassType) {
    switch (searchedClassType) {
      case MAPPER_INTERFACE:
        return qualifiedName.substring(0, qualifiedName.length() - MAPPER_INTERFACE_SUFFIX_LENGTH);
      case MAPPER_FACTORY_INTERFACE:
        return qualifiedName.substring(0, qualifiedName.length() - MAPPER_FACTORY_INTERFACE_SUFFIX_LENGTH);
      default:
        throw new NullPointerException("SearchedClassType can not be null");
    }
  }

  private SearchedClassType computeSearchedClassType(String qualifiedName) {
    if (qualifiedName.endsWith(MAPPER_INTERFACE_SUFFIX)) {
      return SearchedClassType.MAPPER_INTERFACE;
    }
    if (qualifiedName.endsWith(MAPPER_FACTORY_INTERFACE_SUFFIX)) {
      return SearchedClassType.MAPPER_FACTORY_INTERFACE;
    }
    return null;
  }

  private static enum SearchedClassType {
    MAPPER_INTERFACE,
    MAPPER_FACTORY_INTERFACE
  }

  private PsiClass retrieveSourceclass(String mapperFile, GlobalSearchScope scope) {
    PsiFile[] filesByName = PsiShortNamesCache.getInstance(scope.getProject()).getFilesByName(mapperFile + ".java");
    if (filesByName.length == 0) {
      return null;
    }
    Optional<PsiJavaFile> first = FluentIterable.from(Arrays.asList(filesByName)).filter(PsiJavaFile.class).first();
    if (first.isPresent()) {
      return first.get().getClasses()[0];
    }
    return null;
  }

  @NotNull
  @Override
  public PsiClass[] findClasses(@NotNull String qualifiedName, @NotNull GlobalSearchScope scope) {
    PsiClass aClass = findClass(qualifiedName, scope);
    if (aClass == null) {
      return PsiClass.EMPTY_ARRAY;
    }
    return new PsiClass[]{aClass};
  }

  @Nullable
  @Override
  public PsiPackage findPackage(@NotNull String qualifiedName) {
    return super.findPackage(qualifiedName); // use super method because we do not generate any new package
  }

  @NotNull
  @Override
  public PsiPackage[] getSubPackages(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope) {
    return super.getSubPackages(psiPackage, scope); // use super method because we do not generate any new package
  }

  @NotNull
  @Override
  public PsiClass[] getClasses(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope) {

    List<PsiClass> res = Lists.newArrayList();
    for (PsiDirectory dir : psiPackage.getDirectories(scope)) {
      if (dir.getVirtualFile().getFileType() == FileTypes.ARCHIVE) {
        continue;
      }
      for (PsiFile psiFile : dir.getFiles()) {
        if (!(psiFile instanceof PsiJavaFile)) {
          continue;
        }

        PsiClass[] classes = ((PsiJavaFile) psiFile).getClasses();
        if (classes.length == 0) { // current psiFile may be package-info.java which does not contain classes, ignore it
          continue;
        }

        res.addAll(Arrays.asList(classes));

        PsiClass psiClass = classes[0]; // assuming the first class if the public class
        if (!hasMapperAnnotation(psiClass)) {
          // class is not annoted, ignore it
          continue;
        }

        DASourceClass daSourceClass = parsingService.parse(psiClass);
        try {
          sourceClassValidator.validate(daSourceClass);
        } catch (ValidationError validationError) {
          LOGGER.debug(String.format("Failed to validate class %s", psiClass.getQualifiedName()), validationError);
          continue;
        }

        try {
          for (PsiClassGeneratorFacade generatorFacade : ImmutableList.of(
              new MapperInterfaceFacade(daSourceClass, scope, sourceGenerationService),
              new MapperFactoryInterfaceGenerator(daSourceClass, scope, sourceGenerationService),
              new MapperImplGenerator(daSourceClass, scope, sourceGenerationService),
              new MapperFactoryImplGenerator(daSourceClass, scope, sourceGenerationService),
              new MapperFactoryClassGenerator(daSourceClass, scope, sourceGenerationService)
          )) {
            Optional<PsiClass> generatePsiClass = generatorFacade.generatePsiClass();
            if (generatePsiClass.isPresent()) {
              res.add(generatePsiClass.get());
            }

          }
        } catch (IOException e) {
          LOGGER.error("Failed to generate source files");
        }
      }
    }

    return res.toArray(new PsiClass[res.size()]);
  }

  private static abstract class PsiClassGeneratorFacade {
    protected final FileGeneratorContext generatorContext;
    protected final GlobalSearchScope scope;
    protected final SourceGenerationService sourceGenerationService;

    private PsiClassGeneratorFacade(DASourceClass daSourceClass, GlobalSearchScope scope,
                                    SourceGenerationService sourceGenerationService) {
      this.scope = scope;
      this.sourceGenerationService = sourceGenerationService;
      this.generatorContext = new DefaultFileGeneratorContext(daSourceClass);
    }

    private Optional<PsiClass> generatePsiClass() throws IOException {
      if (shouldGenerate()) {
        PsiClassGeneratorDelegate delegate = new PsiClassGeneratorDelegate(scope.getProject());
        generate(delegate);
        return Optional.of(delegate.getGeneratedPsiClass());
      }
      return Optional.absent();
    }

    protected abstract boolean shouldGenerate();

    protected abstract void generate(PsiClassGeneratorDelegate delegate) throws IOException;

  }

  private static class PsiClassGeneratorDelegate implements SourceWriterDelegate {
    private final Project project;
    private PsiClass generatedPsiClass;

    private PsiClassGeneratorDelegate(Project project) {
      this.project = project;
    }

    private PsiClass getGeneratedPsiClass() {
      return generatedPsiClass;
    }

    @Override
    public void generateFile(SourceGenerator sourceGenerator, FileGeneratorContext context) throws IOException {
      StringBuffer buffer = new StringBuffer();
      sourceGenerator.writeFile(new BufferedWriter(new StringBufferWriter(buffer)), context);
      // ((PsiJavaFile) PsiFileFactory.getInstance(project).createFileFromText(sourceGenerator.fileName(context), JavaFileType.INSTANCE, buffer.toString(), LocalTimeCounter     .currentTime(), false, false)).getClasses()[0].getImplementsListTypes()
      PsiJavaFile psiJavaFile = (PsiJavaFile) PsiFileFactory.getInstance(project)
                                                            .createFileFromText(sourceGenerator.fileName(context),
                                                                JavaFileType.INSTANCE, buffer.toString()
                                                            );
      this.generatedPsiClass = psiJavaFile.getClasses()[0];
    }

  }

  private static class MapperInterfaceFacade extends PsiClassGeneratorFacade {

    private MapperInterfaceFacade(DASourceClass daSourceClass,
                                  GlobalSearchScope scope,
                                  SourceGenerationService sourceGenerationService) {
      super(daSourceClass, scope, sourceGenerationService);
    }

    @Override
    protected boolean shouldGenerate() {
      return true;
    }

    @Override
    protected void generate(PsiClassGeneratorDelegate delegate) throws IOException {
      sourceGenerationService.generateMapperInterface(generatorContext, delegate);
    }
  }

  private static class MapperFactoryInterfaceGenerator extends PsiClassGeneratorFacade {

    public MapperFactoryInterfaceGenerator(DASourceClass daSourceClass,
                                           GlobalSearchScope scope,
                                           SourceGenerationService sourceGenerationService) {
      super(daSourceClass, scope, sourceGenerationService);
    }

    @Override
    protected boolean shouldGenerate() {
      return sourceGenerationService.shouldGenerateMapperFactoryInterface(generatorContext);
    }

    @Override
    protected void generate(PsiClassGeneratorDelegate delegate) throws IOException {
      sourceGenerationService.generateMapperFactoryInterface(generatorContext, delegate);
    }
  }

  private static class MapperImplGenerator extends PsiClassGeneratorFacade {

    public MapperImplGenerator(DASourceClass daSourceClass,
                               GlobalSearchScope scope,
                               SourceGenerationService sourceGenerationService) {
      super(daSourceClass, scope, sourceGenerationService);
    }

    @Override
    protected boolean shouldGenerate() {
      return sourceGenerationService.shouldGenerateMapperImpl(generatorContext);
    }

    @Override
    protected void generate(PsiClassGeneratorDelegate delegate) throws IOException {
      sourceGenerationService.generateMapperImpl(generatorContext, delegate);
    }
  }

  private static class MapperFactoryImplGenerator extends PsiClassGeneratorFacade {

    public MapperFactoryImplGenerator(DASourceClass daSourceClass,
                                      GlobalSearchScope scope,
                                      SourceGenerationService sourceGenerationService) {
      super(daSourceClass, scope, sourceGenerationService);
    }

    @Override
    protected boolean shouldGenerate() {
      return sourceGenerationService.shouldGenerateMapperFactoryImpl(generatorContext);
    }

    @Override
    protected void generate(PsiClassGeneratorDelegate delegate) throws IOException {
      sourceGenerationService.generateMapperFactoryImpl(generatorContext, delegate);
    }
  }

  private static class MapperFactoryClassGenerator extends PsiClassGeneratorFacade {

    public MapperFactoryClassGenerator(DASourceClass daSourceClass,
                                       GlobalSearchScope scope,
                                       SourceGenerationService sourceGenerationService) {
      super(daSourceClass, scope, sourceGenerationService);
    }

    @Override
    protected boolean shouldGenerate() {
      return sourceGenerationService.shouldGenerateMapperFactoryClass(generatorContext);
    }

    @Override
    protected void generate(PsiClassGeneratorDelegate delegate) throws IOException {
      sourceGenerationService.generateMapperFactoryClass(generatorContext, delegate);
    }
  }

  @NotNull
  @Override
  public Set<String> getClassNames(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope) {
    return super.getClassNames(psiPackage, scope
    ); // super method uses getClasses(PsiPackage, GlobalSearchScope) in a way that suits us
  }

  @Override
  public boolean processPackageDirectories(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope,
                                           @NotNull Processor<PsiDirectory> consumer) {
    return super.processPackageDirectories(psiPackage, scope, consumer
    ); // don't know what's that method for, use supermethod for now
  }

  @NotNull
  @Override
  public PsiClass[] getClasses(@Nullable String className, @NotNull PsiPackage psiPackage,
                               @NotNull GlobalSearchScope scope) {
    return super.getClasses(className, psiPackage, scope
    ); // super method uses getClasses(PsiPackage, GlobalSearchScope) in a way that suits us
  }
}
