package fr.phan.damapping.intellij.plugin.integration.provider;

import fr.phan.damapping.annotation.Mapper;
import fr.phan.damapping.intellij.plugin.integration.psiparsing.PsiParsingService;
import fr.phan.damapping.intellij.plugin.integration.psiparsing.impl.PsiParsingServiceImpl;
import fr.phan.damapping.processor.model.DASourceClass;
import fr.phan.damapping.processor.sourcegenerator.DefaultFileGeneratorContext;
import fr.phan.damapping.processor.sourcegenerator.FileGeneratorContext;
import fr.phan.damapping.processor.sourcegenerator.SourceGenerationService;
import fr.phan.damapping.processor.sourcegenerator.SourceGenerationServiceImpl;
import fr.phan.damapping.processor.sourcegenerator.SourceGenerator;
import fr.phan.damapping.processor.sourcegenerator.SourceWriterDelegate;
import fr.phan.damapping.processor.validator.DASourceClassValidator;
import fr.phan.damapping.processor.validator.DASourceClassValidatorImpl;
import fr.phan.damapping.processor.validator.ValidationError;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.Lists;

import com.intellij.ide.highlighter.JavaFileType;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.fileTypes.FileTypes;
import com.intellij.openapi.project.Project;
import com.intellij.psi.JavaPsiFacade;
import com.intellij.psi.PsiAnnotation;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiDirectory;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiElementFinder;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiFileFactory;
import com.intellij.psi.PsiImportList;
import com.intellij.psi.PsiImportStatement;
import com.intellij.psi.PsiJavaCodeReferenceElement;
import com.intellij.psi.PsiJavaFile;
import com.intellij.psi.PsiPackage;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.util.Processor;
import org.codehaus.groovy.runtime.StringBufferWriter;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * DAMappingElementFinder - IDEA extension responsible for making interfaces generated by the DAMapping annotation
 * processor visible to IDEA even though the annotation processor hasn't run thus providing feedback to the user
 * that her usage of generated interfaces is valid or not.
 *
 * @author SÃ©bastien Lesaint
 */
public class DAMappingElementFinder extends PsiElementFinder {
  private static final Logger LOGGER = Logger.getInstance(DAMappingAugmentProvider.class.getName());

  private static final String MAPPER_INTERFACE_SUFFIX = "Mapper";
  private static final int MAPPER_INTERFACE_SUFFIX_LENGTH = MAPPER_INTERFACE_SUFFIX.length();
  private static final String MAPPER_FACTORY_INTERFACE_SUFFIX = "MapperFactory";
  private static final int MAPPER_FACTORY_INTERFACE_SUFFIX_LENGTH = MAPPER_FACTORY_INTERFACE_SUFFIX.length();
  private static final String MAPPER_ANNOTATION_TEXT = "@" + Mapper.class.getSimpleName();
  private static final String MAPPER_QUALIFIED_ANNOTATION_TEXT = "@" + Mapper.class.getName();

  private final PsiParsingService parsingService;
  private final DASourceClassValidator sourceClassValidator;
  private final SourceGenerationService sourceGenerationService;

  public DAMappingElementFinder() {
    this(new PsiParsingServiceImpl(), new DASourceClassValidatorImpl(), new SourceGenerationServiceImpl());
  }

  public DAMappingElementFinder(PsiParsingService parsingService, DASourceClassValidator sourceClassValidator,
                                SourceGenerationService sourceGenerationService) {
    this.parsingService = parsingService;
    this.sourceClassValidator = sourceClassValidator;
    this.sourceGenerationService = sourceGenerationService;
    LOGGER.debug("DAMappingElementFinder created");
  }

  @Nullable
  @Override
  public PsiClass findClass(@NotNull String qualifiedName, final @NotNull GlobalSearchScope scope) {
    SearchedClassType searchedClassType = computeSearchedClassType(qualifiedName);
    if (searchedClassType == null) {
      LOGGER.debug(String.format("class %s is not a class generated by DAMapping", qualifiedName));
      return null;
    }

    String mapperFile = extractMapperQualifiedName(qualifiedName, searchedClassType);
    PsiClass psiClass = retrieveSourceclass(mapperFile, scope);
    if (psiClass == null) {
      LOGGER.debug(String.format("Class %s not found", mapperFile));
      return null;
    }

    if (!hasMapperAnnotation(psiClass)) {
      LOGGER.debug(String.format("Class %s is not annoted with @Mapper", mapperFile));
      return null;
    }

    DASourceClass daSourceClass = parsingService.parse(psiClass);
    try {
      sourceClassValidator.validate(daSourceClass);
    } catch (ValidationError validationError) {
      LOGGER.error("Validation failed", validationError);
      return null;
    }

    try {
      PsiClassGeneratorDelegate delegate = new PsiClassGeneratorDelegate(scope.getProject(), psiClass);
      switch (searchedClassType) {
        case MAPPER_INTERFACE:
          sourceGenerationService.generateMapperInterface(
              new DefaultFileGeneratorContext(daSourceClass),
              delegate
          );
          break;
        case MAPPER_FACTORY_INTERFACE:
          sourceGenerationService.generateMapperFactoryInterface(
              new DefaultFileGeneratorContext(daSourceClass),
              delegate
          );
          break;
      }
      return delegate.getGeneratedPsiClass();
    } catch (IOException e) {
      LOGGER.error("Failed to generate source files");
    }

    return null;
  }

  private boolean hasMapperAnnotation(PsiClass psiClass) {
    if (psiClass.getModifierList() == null || psiClass.getModifierList().getAnnotations() == null) {
      return false;
    }

    // look for annotation @Mapper or @com.google.common.base.Function on class
    if (!FluentIterable.from(Arrays.asList(psiClass.getModifierList().getAnnotations()))
                       .filter(new Predicate<PsiAnnotation>() {
                         @Override
                         public boolean apply(@javax.annotation.Nullable PsiAnnotation psiAnnotation) {
                           return psiAnnotation != null
                               && (MAPPER_ANNOTATION_TEXT.equals(psiAnnotation.getText())
                               || MAPPER_QUALIFIED_ANNOTATION_TEXT.equals(psiAnnotation.getText()));
                         }
                       }
                       ).first().isPresent()) {
      return false;
    }

    // look for the import of Guava's Function
    for (PsiElement fileElement : psiClass.getParent().getChildren()) {
      if (fileElement instanceof PsiImportList) {
        for (PsiElement importListElement : fileElement.getChildren()) {
          if (importListElement instanceof PsiImportStatement) {
            for (PsiElement element : importListElement.getChildren()) {
              if (element instanceof PsiJavaCodeReferenceElement) {
                if (Function.class.getName().equals(element.getText())) {
                  return true;
                }
              }
            }
          }

        }
      }
    }
    return false;
    // ((PsiJavaFile)psiPackage.getDirectories(scope)[0].getFiles()[0]).getClasses()[0].getModifierList()
    // .getAnnotations()[0].getText() = "@Mapper"

    // ((PsiJavaFile)psiPackage.getDirectories(scope)[0].getFiles()[0]).getClasses()[0].getParent().getChildren()[0]
    // .getChildren() : import list to filter on type PsiImportStatement
    // PsiImportStatement to filter on PsiImportStatement.getChildren() : type PsiJavaCodeReferenceElement
    // PsiJavaCodeReferenceElement to filter on getText() = Function.class.getName()
  }

  private String extractMapperQualifiedName(String qualifiedName,
                                            @NotNull SearchedClassType searchedClassType) {
    switch (searchedClassType) {
      case MAPPER_INTERFACE:
        return qualifiedName.substring(0, qualifiedName.length() - MAPPER_INTERFACE_SUFFIX_LENGTH);
      case MAPPER_FACTORY_INTERFACE:
        return qualifiedName.substring(0, qualifiedName.length() - MAPPER_FACTORY_INTERFACE_SUFFIX_LENGTH);
      default:
        throw new NullPointerException("SearchedClassType can not be null");
    }
  }

  private SearchedClassType computeSearchedClassType(String qualifiedName) {
    if (qualifiedName.endsWith(MAPPER_INTERFACE_SUFFIX)) {
      return SearchedClassType.MAPPER_INTERFACE;
    }
    if (qualifiedName.endsWith(MAPPER_FACTORY_INTERFACE_SUFFIX)) {
      return SearchedClassType.MAPPER_FACTORY_INTERFACE;
    }
    return null;
  }

  private static enum SearchedClassType {
    MAPPER_INTERFACE,
    MAPPER_FACTORY_INTERFACE
  }

  private static class PsiClassGeneratorDelegate implements SourceWriterDelegate {
    private final Project project;
    private final PsiElement psiElement;
    private PsiClass generatedPsiClass;

    private PsiClassGeneratorDelegate(Project project, PsiElement psiElement) {
      this.project = project;
      this.psiElement = psiElement;
    }

    private PsiClass getGeneratedPsiClass() {
      return generatedPsiClass;
    }

    @Override
    public void generateFile(SourceGenerator sourceGenerator, FileGeneratorContext context) throws IOException {
      StringBuffer buffer = new StringBuffer();
      sourceGenerator.writeFile(new BufferedWriter(new StringBufferWriter(buffer)), context);
      PsiJavaFile psiJavaFile = (PsiJavaFile) PsiFileFactory.getInstance(project)
                                                            .createFileFromText(sourceGenerator.fileName(context),
                                                                JavaFileType.INSTANCE, buffer.toString()
                                                            );
      this.generatedPsiClass = psiJavaFile.getClasses()[0];
//      this.generatedPsiClass = JavaPsiFacade.getElementFactory(project)
//                                            .createClassFromText(buffer.toString(),
//                                                psiElement /*TODO verify what is this second argument*/
//                                            );
    }

  }

  private PsiClass retrieveSourceclass(String mapperFile, GlobalSearchScope scope) {
    return JavaPsiFacade.getInstance(scope.getProject()).findClass(mapperFile, scope);
  }

  @NotNull
  @Override
  public PsiClass[] findClasses(@NotNull String qualifiedName, @NotNull GlobalSearchScope scope) {
    return new PsiClass[0]; // TODO call findClass and return array never containing null
  }

  @Nullable
  @Override
  public PsiPackage findPackage(@NotNull String qualifiedName) {
    return super.findPackage(qualifiedName); // use super method because we do not generate any new package
  }

  @NotNull
  @Override
  public PsiPackage[] getSubPackages(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope) {
    return super.getSubPackages(psiPackage, scope); // use super method because we do not generate any new package
  }

  @NotNull
  @Override
  public PsiClass[] getClasses(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope) {

    List<PsiClass> res = Lists.newArrayList();
    for (PsiDirectory dir : psiPackage.getDirectories(scope)) {
      if (dir.getVirtualFile().getFileType() == FileTypes.ARCHIVE) {
        continue;
      }
      for (PsiFile psiFile : dir.getFiles()) {
        if (!(psiFile instanceof PsiJavaFile)) {
          continue;
        }

        PsiClass psiClass = ((PsiJavaFile) psiFile).getClasses()[0]; // assuming the first class if the public class
        if (!hasMapperAnnotation(psiClass)) {
          // class is not annoted, ignore it
          continue;
        }

        // TODO : should we filter out the Mapper and MapperFactory classes from existing source files ?

        DASourceClass daSourceClass = parsingService.parse(psiClass);
        try {
          sourceClassValidator.validate(daSourceClass);
        } catch (ValidationError validationError) {
          LOGGER.debug(String.format("Failed to validate class %s", psiClass.getQualifiedName()), validationError);
          continue;
        }

        try {
          DefaultFileGeneratorContext generatorContext = new DefaultFileGeneratorContext(daSourceClass);
          PsiClassGeneratorDelegate delegate = new PsiClassGeneratorDelegate(scope.getProject(), psiClass);
          sourceGenerationService.generateMapperInterface(generatorContext, delegate);
          PsiClass mapperPsiClass = delegate.getGeneratedPsiClass();
          res.add(mapperPsiClass);
          if (sourceGenerationService.shouldGenerateMapperFactoryInterface(generatorContext)) {
            delegate = new PsiClassGeneratorDelegate(scope.getProject(), psiClass);
            sourceGenerationService.generateMapperFactoryInterface(generatorContext, delegate);

            res.add(delegate.getGeneratedPsiClass());
          }
        } catch (IOException e) {
          LOGGER.error("Failed to generate source files");
        }
      }
    }

    return res.toArray(new PsiClass[res.size()]);
  }

  @NotNull
  @Override
  public Set<String> getClassNames(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope) {
    return super.getClassNames(psiPackage, scope
    ); // super method uses getClasses(PsiPackage, GlobalSearchScope) in a way that suits us
  }

  @Override
  public boolean processPackageDirectories(@NotNull PsiPackage psiPackage, @NotNull GlobalSearchScope scope,
                                           @NotNull Processor<PsiDirectory> consumer) {
    return super.processPackageDirectories(psiPackage, scope, consumer
    ); // don't know what's that method for, use supermethod for now
  }

  @NotNull
  @Override
  public PsiClass[] getClasses(@Nullable String className, @NotNull PsiPackage psiPackage,
                               @NotNull GlobalSearchScope scope) {
    return super.getClasses(className, psiPackage, scope
    ); // super method uses getClasses(PsiPackage, GlobalSearchScope) in a way that suits us
  }
}
