/**
 * Copyright (C) 2013 Sébastien Lesaint (http://www.javatronic.fr/)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package fr.javatronic.damapping.processor.impl.javaxparsing.element;

import fr.javatronic.damapping.processor.impl.javaxparsing.ElementUtils;
import fr.javatronic.damapping.processor.model.DAName;
import fr.javatronic.damapping.processor.model.factory.DANameFactory;
import fr.javatronic.damapping.util.Maps;

import java.io.IOException;
import java.util.Map;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.lang.model.element.Element;
import javax.lang.model.element.Name;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.ElementFilter;
import javax.lang.model.util.Elements;

import com.sun.source.tree.IdentifierTree;
import com.sun.source.tree.MemberSelectTree;
import com.sun.source.util.SimpleTreeVisitor;
import com.sun.tools.javac.code.Symbol;
import com.sun.tools.javac.model.JavacElements;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.util.Pair;

import static fr.javatronic.damapping.processor.impl.javaxparsing.element.EmptyElementImports.EMPTY_ELEMENT_IMPORTS;

/**
 * ElementUtilsFactory - Factory for {@link fr.javatronic.damapping.processor.impl.javaxparsing.ElementUtils} objects.
 *
 * @author Sébastien Lesaint
 */
public final class ElementUtilsFactory {

  private static final QualifiedIdentifierVisitor IMPORT_QUALIFIED_NAME_VISITOR = new QualifiedIdentifierVisitor();

  private ElementUtilsFactory() {
    // prevents instantiation
  }

  @Nonnull
  public static ElementUtils from(@Nonnull Elements elements) {
    if (elements instanceof JavacElements) {
      return new JavacElementUtils(elements);
    }

    return new DefaultElementUtils(elements);
  }

  private static void addAllImplicitImports(Elements elements, TypeElement e, Map<Name, String> elementBySimpleName) {
    // add class from specified element's package which are implicitly imported
    // add it first so that if it exists any explicit import with a simpleName of a class in the current package,
    // it will overwrite the one from the current package in the map
    PackageElement currentPackage = elements.getPackageOf(e);
    // retrieve PackageElement of current package using Elements#getPackageElement(CharSequence) to get an up
    // -to-date version
    // of the package (ie. contains the generated classes as enclosed elements)
    // PackageElement returned by Elements#getPackage(Element) returns the PackageElement created for the current
    // package at the same time the Element was created (which is before the classes were generated by DAMapping)
    PackageElement upToDateCurrentPackage = elements.getPackageElement(currentPackage.getQualifiedName());
    addAllFromPackage(upToDateCurrentPackage, elementBySimpleName);
  }

  private static void addAddFromQualifiedImportName(Elements elements, Map<Name, String> elementBySimpleName,
                                                    String qualifiedImport) {
    if (qualifiedImport.endsWith("*")) {
      String packageQualifiedName = qualifiedImport.substring(0, qualifiedImport.indexOf("*") - 1);
      PackageElement packageElement = elements.getPackageElement(packageQualifiedName);
      if (packageElement == null) {
        System.err.println("Failed to retrieve PackageElement for qualifiedName " + packageQualifiedName);
      }
      else {
        addAllFromPackage(packageElement, elementBySimpleName);
      }
    }
    else {
      DAName simpleName = DANameFactory.simpleFromQualified(qualifiedImport);
      elementBySimpleName.put(elements.getName(simpleName), qualifiedImport);
    }
  }

  private static void addAllFromPackage(@Nullable PackageElement currentPackage,
                                        @Nonnull Map<Name, String> elementBySimpleName) {
    if (currentPackage == null || currentPackage.getEnclosedElements().isEmpty()) {
      return;
    }

    for (TypeElement typeElement : ElementFilter.typesIn(currentPackage.getEnclosedElements())) {
      elementBySimpleName.put(typeElement.getSimpleName(), typeElement.getQualifiedName().toString());
    }
  }

  /**
   * This a {@link com.sun.source.tree.TreeVisitor} implemented extending {@link SimpleTreeVisitor} to extract the
   * qualified identifier as a String from a {@link MemberSelectTree}.
   * <p/>
   * <p>
   * A qualified identifier is represented as a tree of {@link MemberSelectTree}s that ends with a {@link
   * IdentifierTree}.
   * </p>
   * <p/>
   * <p>
   * E.g. "foo.bar.Acme":
   * <p/>
   * <pre>
   *   [MemberSelectTree: expression=  identifier=[IdentifierTree: name="Acme"]]
   *                                |
   *                                --> [MemberSelectTree: expression= identifier=[IdentifierTree: name="bar"]]
   *                                                                  |
   *                                                                  --> [MemberSelectTree: expression=null identifier=[IdentifierTree: name="foo"]]
   * </pre>
   * </p>
   */
  private static class QualifiedIdentifierVisitor extends SimpleTreeVisitor<StringBuffer, StringBuffer> {
    @Override
    public StringBuffer visitMemberSelect(MemberSelectTree memberSelectTree, StringBuffer buffer) {
      memberSelectTree.getExpression().accept(this, buffer);
      buffer.append(".").append(memberSelectTree.getIdentifier().toString());
      return buffer;
    }

    @Override
    public StringBuffer visitIdentifier(IdentifierTree identifierTree, StringBuffer buffer) {
      buffer.append(identifierTree.getName().toString());
      return buffer;
    }
  }

  /**
   * {@link ElementUtils} for Javac.
   * <p>
   * Tries to retrieve imports through Javac's JCCompilationUnit class. If it can't (ie. the Element does not compile),
   * defaults to parsing the import statements in the source file directly.
   * </p>
   * <p>
   * There is no compilation between annotation processing rounds
   *  <ul>
   *    <li>file which does not compile when annotation processing starts will never have a compilation unit</li>
   *    <li>however, package will be updated with generated mappers (if they compile) as enclosed elements
   *     from the round that follows the one during which they were generated</li>
   *  </ul>
   * </p>
   */
  private static class JavacElementUtils extends BaseElementUtils<JavacElements> {

    public JavacElementUtils(Elements elements) {
      super((JavacElements) elements);
    }

    @Nonnull
    @Override
    public ElementImports findImports(@Nonnull Element e) throws IOException {
      TypeElement typeElement = asTypeElement(e);
      if (typeElement == null) {
        return EMPTY_ELEMENT_IMPORTS;
      }

      Map<Name, String> elementBySimpleName = Maps.newHashMap();

      addAllImplicitImports(elements, typeElement, elementBySimpleName);

      Pair<JCTree, JCTree.JCCompilationUnit> treeAndTopLevel = elements.getTreeAndTopLevel(typeElement, null, null);
      if (treeAndTopLevel == null || treeAndTopLevel.snd == null) {
        addAllFromSourceFile(elementBySimpleName, typeElement);
      }
      else {
        addAllFromJCImports(elementBySimpleName, treeAndTopLevel.snd, typeElement);
      }

      return new ElementImportsImpl(elementBySimpleName, elements);
    }

    private void addAllFromJCImports(Map<Name, String> elementBySimpleName,
                                     JCTree.JCCompilationUnit compilationUnit,
                                     Element element) {
      com.sun.tools.javac.util.List<JCTree.JCImport> imports = compilationUnit.getImports();
      if (imports == null || imports.isEmpty()) {
        return;
      }

      for (JCTree.JCImport jcImport : imports) {
        String qualifiedImport = IMPORT_QUALIFIED_NAME_VISITOR.visit(
            jcImport.getQualifiedIdentifier(), new StringBuffer()
        ).toString();

        if (qualifiedImport.isEmpty()) {
          System.err.println("Failed to retrieve String qualified value for import " + jcImport);
          continue;
        }

        addAddFromQualifiedImportName(elements, elementBySimpleName, qualifiedImport);
      }
    }

    private void addAllFromSourceFile(Map<Name, String> elementBySimpleName, TypeElement element) throws IOException {
      // so:
      // => we need to parse the source file of dedicated classes which does not compile to get the imports
      // written in source

      // ((Symbol.ClassSymbol) e).sourcefile.getCharContent(true) to retrieve file content
      //  - alternative: ((Symbol.ClassSymbol) e).sourcefile.openReader(true)
      CharSequence sourceContent = ((Symbol.ClassSymbol) element).sourcefile.getCharContent(true);

      // FIXME reimplement parsing import statement with a reader to avoid reading all the file and loading it
      // all in memory

      for (String qualifiedImport : SimplePatternImportStatementParser.INSTANCE.qualifiedNames(sourceContent)) {
        if (qualifiedImport == null || qualifiedImport.isEmpty()) {
          continue;
        }

        addAddFromQualifiedImportName(elements, elementBySimpleName, qualifiedImport);
      }
    }
  }

  /**
   * This is an implementation of {@link ElementUtils} interface which provides a {@code findImports(Element)] method
   * which only supports implicit imports.
   */
  private static class DefaultElementUtils extends BaseElementUtils<Elements> {

    public DefaultElementUtils(Elements elements) {
      super(elements);
    }

    @Nonnull
    @Override
    public ElementImports findImports(@Nonnull Element e) {
      TypeElement typeElement = asTypeElement(e);
      if (typeElement == null) {
        return EMPTY_ELEMENT_IMPORTS;
      }

      Map<Name, String> elementBySimpleName = Maps.newHashMap();

      addAllImplicitImports(elements, typeElement, elementBySimpleName);

      return new ElementImportsImpl(elementBySimpleName, elements);
    }
  }

}
